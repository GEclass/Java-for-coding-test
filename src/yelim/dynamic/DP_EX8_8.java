package yelim.dynamic;

import java.util.*;

public class DP_EX8_8 {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        // 화폐 단위 종류 수 : N
        // 만들어야 하는 금액 : M
        int n = sc.nextInt();
        int m = sc.nextInt();

        // arr 배열은 N개의 화폐 단위 종류 배열
        int[] arr = new int[n];
        for (int i = 0; i < n; i++) {
            arr[i] = sc.nextInt();
        }

        // d 배열은 인덱스 0을 제외한 1원 ~ M원까지 각각의 금액을 만들 수 있는 화폐 최소 개수 배열
        // 앞서 계산된 결과를 저장하기 위한 DP 테이블
        int[] d = new int[m + 1];

        // 금액을 만들 수 없는 경우, 10001이 저장된다.
        // 먼저 d 배열의 초기화는 10001로 한다.
        Arrays.fill(d, 10001);

        // N개 종류의 화폐를 가지고 M원을 만들기 위한 가장 최소한의 화폐 개수
        // 다이나믹 프로그래밍 - 보텀업
        // ai-k : 금액 i - k원을 만들 수 있는 최소한의 화폐 개수
        // ai = min(ai ,ai-k + 1)

        // N = 2, M = 7이면서 화폐 종류는 2, 3, 5일 때,
        // > a1 = d[1] = 10001 (지금의 화페 종류로는 1원을 만들 수 없으므로 10001을 저장한다.)
        // > a2 = d[2] = 1 (지금의 화폐 종류로 2원은 2원 하나로 만들 수 있다.)
        // > a3 = d[3] = 1 (지금의 화폐 종류로 3원은 3원 하나로 만들 수 있다.)
        // > a4 = d[4] = 2 (지금의 화폐 종류로 4원은 2원 두 개로 만들 수 있다.)
        // > a5 = d[5] = 1 (지금의 화폐 종류로 5원은 하나로 만들 수 있다.)

        // N은 1원 부터 시작하므로 0원은 0으로 초기화한다.
        d[0] = 0;

        // 화폐 종류 개수 만큼 반복하기
        for (int i = 0; i < n; i++) {
            // 1원 부터 만들어야 하는 금액 M원까지 반복하면서
            // 각각의 금액을 만들 수 있는 화폐 최소 개수 배열인 d 배열에 최소 개수 저장하기
            for (int j = arr[i]; j <= m; j++) {
                // (i - k)원을 만들 수 있는 경우
                // i = 0일 때,
                //      d[2 - 2] != 10001 > d[2] = Math.min(d[2], d[2 - 2] + 1) = Math.min(1, 1) = 1
                //      d[3 - 2] == 10001
                //      d[4 - 2] != 10001 > d[4] = Math.min(d[4], d[4 - 2] + 1) = Math.min(2, 2) = 2
                //      d[5 - 2] != 10001
                //      d[6 - 2] != 10001 > d[6] = Math.min(d[6], d[5 - 2] + 1) = Math.min(3, 10002) = 3
                //      d[7 - 2] == 10001
                // i = 1일 때,
                //      d[3 - 3] != 10001 > d[3] = Math.min(d[3], d[3 - 3] + 1) = Math.min(1, 1) = 1
                //      d[4 - 3] == 10001 >> min(d[4], d[4 - arr[1] + 1) = min(d[4], d[4 - 3] + 1) = min(2, 10002)
                //      d[5 - 3] != 10001 > d[5] = Math.min(d[5], d[5 - 3] + 1) = Math.min(2, 2) = 2
                //      d[6 - 3] != 10001 > d[6] = Math.min(d[6], d[6 - 3] + 1) = Math.min(2, 2) = 2
                //      d[7 - 3] != 10001 > d[7] = Math.min(d[7], d[7 - 3] + 1) = Math.min(10001, 3) = 3
                // i = 2일 때,
                //      d[5 - 5] != 10001 > d[5] = Math.min(d[5], d[5 - 5] + 1) = Math.min(1, 1) = 1
                //      d[6 - 5] == 10001
                //      d[7 - 5] != 10001 > d[7] = Math.min(d[7], d[7 - 5] + 1) = Math.min(3, 2) = 2
                if (d[j - arr[i]] != 10001) {
                    d[j] = Math.min(d[j], d[j - arr[i]] + 1);
                }
            }
        }

        // 계산된 결과 출력
        if (d[m] == 10001) { // 최종적으로 M원을 만드는 방법이 없는 경우
            System.out.println(-1);
        }
        else {
            System.out.println(d[m]);
        }
    }
}
